# 叶子相似的树

- 问题描述

  请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。

  如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。

  如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。

   


- 问题分析

  画图分析可以得到，通过中序遍历便可以得到该叶值序列，因此可以分别从递归和迭代两个角度来进行中序遍历，一般来说迭代在公司里会更常用，因此这里写迭代做法。

  通过中序遍历得到两个叶值序列，比较二者是否相等则可以判断是否相似，考虑到字符串可以以O(1)时间进行比较，因此采用字符串来存储叶值序列。

  除了求出两个叶值序列再进行比较，也可以先得到一个叶值序列，接着再边中序遍历边判断是否与该序列相等，然而，这种做法不如第一种快，原因是第二次中序遍历在与第一个叶值序列比较时需要遍历该叶值序列，因此造成时间上的开销。

  

- 问题解答

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      bool leafSimilar(TreeNode* root1, TreeNode* root2) {
          string node1;
          if (!root1 && !root2) {
              return true;
          } else if (root1 && root2) {
              inOrder(root1, node1);
              return check(root2, node1);
          } else 
              return false;
      }
      bool check(TreeNode* root, string& node) {
          int i = 0;
          int length = node.size();
          TreeNode* cur = root;
          stack<TreeNode*> st;
          while (!st.empty() || cur != NULL) {
              while (cur != NULL) {
                  st.push(cur);
                  cur = cur->left;
              }
              cur = st.top();
              st.pop();
              if (cur->left == NULL && cur->right == NULL) {
                  if (i < length && node[i] == cur->val) {
                      i ++;
                  } else {
                      return false;
                  }
              }
              cur = cur->right;
          }
          return i == length;
      }
      void inOrder(TreeNode* root, string& node) {
          stack<TreeNode*> st;
          TreeNode* cur = root;
          while (!st.empty() || cur != NULL) {
              while (cur != NULL) {
                  st.push(cur);
                  cur = cur->left;
              }
              cur = st.top();
              st.pop();
              if (cur->left == NULL && cur->right == NULL)
                  node.push_back(cur->val);
              cur = cur->right;
          }
      }
  };
  ```

 ---
 
 # 叶子相似的树-wk

- 问题描述

  > 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。

- 问题分析

  - 此题必须要做的事情就是进行两次遍历，将两棵树的所有叶子节点进行比较
  - 最简单的做法就是将两个节点的叶子节点的值各自放在列表中，最后对比两个列表，这样做最后需要`o(n)`来对比两个列表
  - 有一种更快的做法，就是以拼接字符串的形式来存储所有叶子节点的值，最后只用比较两个字符串是否相等即可
  - 但是会出现一种问题，就是root1的叶子是“1,5"，root2的叶子是”15“，那么如果直接拼接，就是”15“和”15“，导致两个不同的树被误判
  - 因此需要加一个分隔符，区分每一个数字，比如”1-5-“, "15-"，这样就是不同的

- 问题代码

```javascript
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    String dfs(TreeNode root, StringBuilder s) {
        if (root == null) return s;
        if (root.left == null && root.right == null) {
            s = s + "-" + root.val;
            return s.toString();
        } 
        return dfs(root.left, s) + dfs(root.right, s);
    }
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        String s1 = dfs(root1, ""); 
        String s2 = dfs(root2, ""); 
        return s1.equals(s2);
    }
}
```


