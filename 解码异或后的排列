# [1734. 解码异或后的排列](https://leetcode-cn.com/problems/decode-xored-permutation/)-wk

- 问题描述

  > 给你一个整数数组 perm ，它是**前 n 个正整数的排列**，且 n 是个 奇数 。
  >
  > 它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。
  >
  > 给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。

- 问题分析

  - 此题考的是异或操作满足的自反性和结合律，即`a^b^b=a` -> `a^(b^c)^(b^c)=a`
  - 注意题目中所提到的 **前 n 个正整数的排列，n是奇数**，这说明`perm`数组是由1-n打乱顺序得到的，而`1^...^n`的值是与顺序无关的，因此可以知道异或总和固定
  - 假设打乱之后的数组`perm=[a,b,c,..,g,h]`，我们知道，`encoded`数组是通过`a^b, b^c,c^e`得到的，那么`a^b^c^d^e^f^g^h=1^2...^n`，通过`a^b...f^(g^h) ^(g^h) = a^b...^f`, `a^b...d^e^f ^(e^f) = a^b...^d`，由于n是奇数，因此可以最终得到剩余的`a`
  - 通过`a`，结合encode很容易就能得到`perm`了

- 问题代码

```java
class Solution {
    public int[] decode(int[] encoded) {
        int a = 0;
        int n = encoded.length;
        for (int i = 1; i <= n+1;++i) {
            a ^= i;
        }
        int []perm = new int[n+1];
        for (int i = n-1;i >= 0; i-=2) {
            a ^= encoded[i];
        }
        perm[0] = a;
        for (int i = 1;i <= n; ++i) {
            perm[i] = perm[i-1] ^ encoded[i-1];
        }
        return perm;
    }
}
```

